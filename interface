-- InterfaceManager.lua ew
local httpService = game:GetService("HttpService")

local InterfaceManager = {} do
	InterfaceManager.Folder = "FluentSettings"
    InterfaceManager.Settings = {
        Theme = "Dark",
        Acrylic = true,
        Transparency = true,
        MenuKeybind = "LeftControl"
    }

    -- üîÅ T·∫Øt t·∫•t c·∫£ toggle v·ªÅ false nh∆∞ng KH√îNG ghi file
    local function _resetAllToggles_NoSave(Library)
        if not Library then return end
        local SM = rawget(getgenv(), "SaveManager")
        if SM and type(SM)=="table" then SM._suppressSave = true end

        local bags = {}
        if typeof(Library.Flags) == "table"   then table.insert(bags, Library.Flags)   end
        if typeof(Library.Options) == "table" then table.insert(bags, Library.Options) end

        for _, bag in ipairs(bags) do
            for _, flag in pairs(bag) do
                if typeof(flag) == "table" and (flag.Type == "Toggle" or flag.Type == "toggle") then
                    pcall(function()
                        if typeof(flag.SetValue) == "function" then
                            flag:SetValue(false)
                        elseif rawget(flag, "Value") ~= nil then
                            flag.Value = false
                        end
                    end)
                end
            end
        end

        task.defer(function()
            local SM2 = rawget(getgenv(), "SaveManager")
            if SM2 and type(SM2)=="table" then SM2._suppressSave = false end
        end)
    end

    -- üîé T√¨m Fluent GUI ƒëang t·ªìn t·∫°i (kh√¥ng ƒë·ª•ng SettingsHub)
    local function _findExistingFluentGui()
        local CoreGui = game:GetService("CoreGui")
        local roots = { CoreGui }
        local ok, ui = pcall(function() return gethui and gethui() end)
        if ok and typeof(ui)=="Instance" then table.insert(roots, ui) end

        local robloxGui = CoreGui:FindFirstChild("RobloxGui")
        local function isSystemGui(inst) return robloxGui and inst:IsDescendantOf(robloxGui) end

        for _,root in ipairs(roots) do
            for _,g in ipairs(root:GetChildren()) do
                if g:IsA("ScreenGui") and not isSystemGui(g) then
                    if g:GetAttribute("Fluent") == true
                    or g.Name == "Fluent" or g.Name == "FluentUI"
                    or (g:FindFirstChild("AcrylicPaint", true) and g:FindFirstChild("Window", true)) then
                        return g
                    end
                end
            end
        end
        return nil
    end

    -- ========= Meo Button helpers (ch·ªëng tr√πng ·ªü CoreGui & gethui) =========
    local function _getUiRoots()
        local roots = { game:GetService("CoreGui") }
        local ok, ui = pcall(function() return gethui and gethui() end)
        if ok and typeof(ui)=="Instance" then table.insert(roots, ui) end
        return roots
    end

    local function _findMeoButton()
        for _,root in ipairs(_getUiRoots()) do
            local g = root:FindFirstChild("Meo_Button")
            if g and g:IsA("ScreenGui") then
                return g
            end
        end
        return nil
    end

    local function _preferredRoot()
        local ok, ui = pcall(function() return gethui and gethui() end)
        if ok and typeof(ui)=="Instance" then return ui end
        return game:GetService("CoreGui")
    end

    local function _ensureMeoButton(Settings)
        if _findMeoButton() then return end -- ƒë√£ c√≥, kh√¥ng t·∫°o tr√πng

        local VIM = game:GetService("VirtualInputManager")
        local UIS = game:GetService("UserInputService")
        local TweenService = game:GetService("TweenService")

        local parent = _preferredRoot()

        local gui = Instance.new("ScreenGui")
        gui.Name = "Meo_Button"
        gui.IgnoreGuiInset = true
        gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
        gui.ResetOnSpawn = false
        gui.Parent = parent

        local btn = Instance.new("ImageButton")
        btn.Name = "CtrlSquare"
        btn.Size = UDim2.fromOffset(50, 50)
        btn.AnchorPoint = Vector2.new(1, 1)
        btn.Position = UDim2.new(1, -20, 1, -20)
        btn.BackgroundColor3 = Color3.fromRGB(44, 44, 44)
        btn.Image = "rbxassetid://138537648998329"
        btn.ScaleType = Enum.ScaleType.Fit
        btn.AutoButtonColor = true
        btn.Parent = gui

        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 10)
        local stroke = Instance.new("UIStroke", btn)
        stroke.Thickness = 1
        stroke.Color = Color3.fromRGB(200, 150, 180)

        -- Drag + clamp
        local dragging, dragStart, startPos
        local function clampToViewport(pos)
            local cam = workspace.CurrentCamera
            if not cam then return pos end
            local vw, vh = cam.ViewportSize.X, cam.ViewportSize.Y
            local x = math.clamp(pos.X.Offset, -vw + 20, -20)
            local y = math.clamp(pos.Y.Offset, -vh + 20, -20)
            return UDim2.new(pos.X.Scale, x, pos.Y.Scale, y)
        end

        btn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = btn.Position
            end
        end)
        UIS.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                local target = UDim2.new(
                    startPos.X.Scale, startPos.X.Offset + delta.X,
                    startPos.Y.Scale, startPos.Y.Offset + delta.Y
                )
                btn.Position = clampToViewport(target)
            end
        end)
        UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)

        -- Slime + g·ª≠i keybind
        local function slimeEffect()
            local tweenIn = TweenService:Create(btn, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Size = UDim2.fromOffset(44, 44)
            })
            local tweenOut = TweenService:Create(btn, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = UDim2.fromOffset(50, 50)
            })
            tweenIn:Play(); tweenIn.Completed:Wait(); tweenOut:Play()
        end
        btn.MouseButton1Click:Connect(function()
            slimeEffect()
            local keyName = tostring(Settings and Settings.MenuKeybind or "LeftControl")
            local key = Enum.KeyCode[keyName] or Enum.KeyCode.LeftControl
            VIM:SendKeyEvent(true, key, false, game)
            task.wait(0.05)
            VIM:SendKeyEvent(false, key, false, game)
        end)
    end

    -- üîó G·∫Øn auto-reset khi GUI b·ªã x√≥a
    local function _attachAutoReset(Library)
        if not Library then return end
        local gui = Library.GUI
        if not gui then return end
        if Library.___AutoResetAttached then return end
        Library.___AutoResetAttached = true

        pcall(function() gui:SetAttribute("Fluent", true) end)

        if gui.Destroying then
            gui.Destroying:Connect(function() _resetAllToggles_NoSave(Library) end)
        end
        gui.AncestryChanged:Connect(function(_, parent)
            if parent == nil then _resetAllToggles_NoSave(Library) end
        end)
    end

    -- ========= InterfaceManager core =========
    function InterfaceManager:SetFolder(folder)
		self.Folder = folder
		self:BuildFolderTree()
	end

    function InterfaceManager:SetLibrary(library)
        local Settings = InterfaceManager.Settings

        -- ‚ùó Kh√¥ng t·∫°o tr√πng Fluent GUI: n·∫øu ƒë√£ c√≥ GUI th√¨ li√™n k·∫øt v√†o n√≥
        local existingGui = _findExistingFluentGui()
        if existingGui then
            local running = rawget(getgenv(), "Fluent")
            if type(running) == "table" and running.GUI == existingGui then
                self.Library = running
                _attachAutoReset(running)
            else
                -- shim t·ªëi thi·ªÉu ƒë·ªÉ BuildInterfaceSection kh√¥ng l·ªói khi kh√¥ng c√≥ object Library ƒë·∫ßy ƒë·ªß
                self.Library = self.Library or { GUI = existingGui, Themes = { "Dark","Light" }, SetTheme = function() end }
                _attachAutoReset(self.Library)
            end

            -- n·∫øu truy·ªÅn v√†o library m·ªõi kh√°c GUI ƒëang c√≥ ‚Üí ph√° h·ªßy ƒë·ªÉ tr√°nh tr√πng
            if library and library.GUI and library.GUI ~= existingGui then
                print("‚ö†Ô∏è GUI Fluent ƒë√£ c√≥ s·∫µn, kh√¥ng t·∫°o th√™m.")
                pcall(function()
                    if typeof(library.Destroy) == "function" then
                        library:Destroy()
                    elseif library.GUI then
                        library.GUI:Destroy()
                    end
                end)
            end

            -- ƒë·∫£m b·∫£o lu√¥n c√≥ Meo Button d√π reattach
            _ensureMeoButton(Settings)
            return
        end

        -- Ch∆∞a c√≥ GUI ‚Üí d√πng library truy·ªÅn v√†o
        if self.Library and self.Library ~= library then
            pcall(function()
                if typeof(self.Library.Destroy) == "function" then
                    self.Library:Destroy()
                elseif self.Library.GUI then
                    self.Library.GUI:Destroy()
                end
            end)
            _resetAllToggles_NoSave(self.Library)
        end

        self.Library = library
        _attachAutoReset(library)
        _ensureMeoButton(Settings)
	end

    function InterfaceManager:BuildFolderTree()
        local parts = string.split(self.Folder, "/")
		local paths = {}
		for idx = 1, #parts do
			paths[#paths + 1] = table.concat(parts, "/", 1, idx)
		end
		table.insert(paths, self.Folder)
		table.insert(paths, self.Folder .. "/settings")
		for _, p in ipairs(paths) do
			if not isfolder(p) then makefolder(p) end
		end
	end

    function InterfaceManager:SaveSettings()
        writefile(self.Folder .. "/options.json", httpService:JSONEncode(InterfaceManager.Settings))
    end

    function InterfaceManager:LoadSettings()
        local path = self.Folder .. "/options.json"
        if isfile(path) then
            local ok, decoded = pcall(function()
                return httpService:JSONDecode(readfile(path))
            end)
            if ok and type(decoded)=="table" then
                for k,v in next, decoded do
                    InterfaceManager.Settings[k] = v
                end
            end
        end
    end

    -- ========= UI Section =========
    function InterfaceManager:BuildInterfaceSection(tab)
        if not self or not self.Library then
            -- kh√¥ng c√≤n nil n·ªØa trong flow b√¨nh th∆∞·ªùng, nh∆∞ng gi·ªØ guard cho ch·∫Øc
            return
        end

		local Library = self.Library
        local Settings = InterfaceManager.Settings
        InterfaceManager:LoadSettings()

		local section = tab:AddSection("Interface")

        local themes = Library and Library.Themes
        if typeof(themes) ~= "table" or #themes == 0 then
            themes = { "Dark", "Light" }
        end

		local InterfaceTheme = section:AddDropdown("InterfaceTheme", {
			Title = "Theme",
			Description = "Changes the interface theme.",
			Values = themes,
			Default = Settings.Theme,
			Callback = function(Value)
                if Library and typeof(Library.SetTheme)=="function" then
				    Library:SetTheme(Value)
                end
                Settings.Theme = Value
                InterfaceManager:SaveSettings()
			end
		})
        pcall(function() InterfaceTheme:SetValue(Settings.Theme) end)

		local MenuKeybind = section:AddKeybind("MenuKeybind", {
            Title = "Minimize Bind",
            Default = Settings.MenuKeybind
        })
		MenuKeybind:OnChanged(function()
			Settings.MenuKeybind = MenuKeybind.Value
            InterfaceManager:SaveSettings()
		end)
		Library.MinimizeKeybind = MenuKeybind

        -- v·∫´n an to√†n n·∫øu g·ªçi l·∫°i
        _ensureMeoButton(Settings)
    end
end

return InterfaceManager
